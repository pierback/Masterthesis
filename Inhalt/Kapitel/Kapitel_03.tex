\chapter{System Architektur}
\label{kap:Kapitel03}

\section{Überblick}
Im folgenden wird nun die System Architektur und der Workflow erläutert, welche als Grundlage für die Studie dienten, um die in 1.2 geschilderte Problemstellung abzubilden und letztendlich zu lösen.

\subsection{Architektur}
\label{subsec:architecture}
Um ein besseres Bild davon zu bekommen, wie die einzelnen Komponenten
zusammenhängen bzw. welche Aufgaben diese in Wechselwirkung zu anderen Instanzen übernehmen und ausführen, wird zunächst die Architektur des Systems erläutert. Als Basis soll dabei die Abbildung \ref{img:sysarc} dienen, anhand jener vorrangig die jeweiligen Komponenten bezüglich ihrer Funktionsweise beschrieben werden. Das Zusammenspiel der Anwendungen wird im Anschluss unter \ref{subsec:workflow} detailliert beleuchtet.

\clearpage
\newpage

\begin{figure}[th!]
	\centering
	\includegraphics[width=.99\columnwidth]{./Abbildungen/Kapitel_03/system_architecture.png}
	\caption{Systemarchitektur}
	\label{img:sysarc}
\end{figure}
\FloatBarrier

\nlparagraph{Lehrstuhl Server}
Der Lehrstuhlserver ist dafür zuständig einen Großteil der Anwendungen zu hosten bzw. zu starten.
Dies gilt sowohl für den HTTP-Fileserver als auch für die Learner-Anwendung, welche dessen Betriebssystem als Plattform nutzen.\\
Auch die Blockchain wird auf dem Server gestartet und verwendet diesen zudem als \textit{full-node}, um Transaktionen zu minen.\\
Der Server ist im Grunde die Basis der Anwendungen, dessen primäre Funktionsweise darin besteht, jenen eine Plattform zu bieten und mit Rechenleistung zu versorgen.

\nlparagraph{Learner}
Der sogenannte \textit{Learner} ist eine in Golang implementierte Softwareanwendung, deren Hauptaufgabe darin besteht, das Kaffeetrinkverhalten der Nutzer zu erlernen - wovon auch die Namensgebung der Anwendung stammt.
Um dies zu erreichen, wurde die Anwendung in Submodule unterteilt, welche einen dedizierten Aufgabenbereich abdecken und eigenständig bearbeiten.
Trotz ihrer autarken Funktionsweise, kann das Trinkverhalten letztendlich erst in der gegenseitigen Wechselwirkung jener erlernt werden. \\
Die Submodule lauten wie folgt:
\begin{itemize}
	\item Q-Learning
	\item Worker
	\item Watcher
	\item (Smart Contract Deployment Skript)
\end{itemize}

Das \textbf{Q-Learning} ist, wie der Name bereits impliziert, für das eigentliche Erlernen des Trinkverhaltens zuständig. Es ist im Grunde die Implementierung des Q-Learning Algorithmus, sowie die damit einhergehende Zustandsraummodiellerung, welche aber unter \ref{subsec:modulation} genauer erläutert wird.
\\\\
Der \textbf{Worker} ist einerseits für die Userverwaltung und andererseits für die, in einem festgelegten Intervall stattfindende, Ausführung des Q-Learning Algorithmus, zuständig. (vgl. Kap. \ref{subsec:learning})
\\\\
Der \textbf{Watcher} beobachtet Events, die vom Smart-Contract \textit{Beverage-List} ausgelöst wurden. Die Daten, welches das Event beinhaltet, werden daraufhin verwendet den Q-Learning Algorithmus damit zu \quotes{befüllen} und aufgrund dessen das Trinkverhalten zu erlernen.
\\\\
Das \textbf{Smart Contract Deployment Skript}, ist in der Form zwar nicht in der Systemarchitektur vorhanden. Da es aber auch ein Submodul des \textit{Learners} und für das gesamte Konstrukt dahingehend essentiell ist, weil es die Smart Contracts auf der Blockchain installiert und im Zuge dessen erst die Verbindung zwischen Blockchain und Learner ermöglicht, wird es in dieser Auflistung trotzdem aufgeführt.

\nlparagraph{Fileserver}
Der Fileserver ist eine Golang-Anwendung, welche eine rudimentäre REST (REpresentational State Transfer) API (Application Programming Interface) zur Verfügung stellt.
Von den bereits erwähnten CRUD-Operationen, welche als grundlegend für alle persistenten Datenspeicher angesehen werden können, implementiert dieser nur das GET und das PUT. Sowohl die PATCH als auch die DELETE Operation bieten keinen Mehrwert für die Gesamtarchitektur bzw. den Workflow und sind in Anbetracht dessen nicht implementiert.\\
Das bedeutet, die Hauptaufgabe des Fileservers besteht darin, Dateien zu empfangen und zu speichern (PUT) und diese auf Anfrage (GET) an einen Antragsteller wieder zu versenden.\\
Außerdem bietet die Anwendung zusätzlich zur API einen UDP-Broadcast, welcher vor allem beim \quotes{Testing} und beim Setup eine große Erleichterung darstellt. Dieser Broadcast versendet in seinen Nachrichten die IP-Adresse des Lehrstuhl-Servers und somit seine eigene, sowie die der Blockchain.\\
Da die IP-Adresse und der Port des Broadcasts stets gleich bleiben, sich aber die Host-IP der Blockchain und des Fileservers je nach Deployment theoretisch ändern können - was in der Entwicklungsphase sehr oft der Fall war - müssen sich sowohl der Learner als auch die Tablet-App lediglich auf den Broadcast \quotes{subscriben} und können dadurch die IP der Blockchain und des Fileservers erfahren. Durch diese dynamische Zuweisung der IP-Adresse, müssen keine Updates beim Learner und der App durchgeführt werden, sollte die Blockchain und der Fileserver auf einem anderen Host deployed werden. \\
Aufgrund der Tatsache, dass sich die IP-Adresse des Lehrstuhl-Servers während der Studie nicht ändert, ist der UDP-Broadcast auch nicht in der Abbildung \ref{img:sysarc} der Systemarchitektur berücksichtigt worden. Der Anwendungsbereich ist trotz alledem im Bereich der Testphase und auch für die künftige Projekte,bei denen das System Verwendung findet, definitiv vorhanden.

\nlparagraph{Blockchain}
Die Blockchain ist eine private, eigens für die Studie erstellte Ethereum-Blockchain, dessen \textit{Genesis-Block} aus dem JSON-File (vgl. Abbildung \ref{img:gen}) generiert wird. Die Erläuterungen zu den jeweiligen Key-Value-Pairs sind unter Kap. \ref{subsec:genesis} zu finden.
Das Generieren und Starten der Blockchain erfolgt auf dem Lehrstuhlserver.
Dabei hostet der Server zudem eine sogenannte \textit{full-node} (hier auch \quotes{Miner} genannt) der Blockchain, welche dafür zuständig ist Transaktionen zu berechnen und zu bestätigen.
Aus Ressourcengründen ist der Miner der einzige im Gesamtsystem, was aus theoretischer Sicht einen \quotes{Single Point of Failure} als Nachteil mit sich zieht. Das bedeutet, sollte die full-node ausfallen, könnten keine Transaktionen mehr bestätigt werden. Da es weder während der Entwicklungsphase, noch während der Studie zu einem einzigen Ausfall kam, ist dieser Nachteil als sehr klein einzuschätzen, weswegen auch keine weitere full-node zum System hinzugefügt wurde. Allerdings besteht der große Vorteil darin, dass Transaktionen sehr schnell bestätigt werden, da es keine weiteren \quotes{Nodes} gibt, die um die Berechnung eines Blocks konkurrieren. \\
Vor allem aus Sicht der User-Experience stellt das einen großen Mehrwert dar, da ein User in wenigen Sekunden erfährt ob seine Transaktion erfolgreich durchgeführt wurde. Dies kann bei anderen Blockchains wie z.B. Bitcoin bis zu 10 Minuten dauern \cite{MINING:kryptopedia}, was im Kontext der Systemarchitektur nicht tragbar wäre.\\\\
Um letztendlich mit der Blockchain zu kommunizieren und ihr Potential in voller Gänze ausschöpfen zu können, werden auf diese sogenannte \textit{Smart-Contracts} deployed. Im Rahmen der Systemarchitektur sind es zwei dedizierte Smart-Contracts (\textit{Coffee-Coin} \ref{subsec:cc}, \textit{Beverage-List} \ref{subsec:bl}), welche komplett unabhängig voneinander agieren.


\nlparagraph{Smart Contracts}
Die Smart Contracts, welche auf die Blockchain deployed werden, tragen die Titel \textit{Coffee-Coin} und \textit{Beverage-List}. Diese decken zwei völlig unterschiedliche Aufgabenbereiche ab, weswegen sie  unabhängig voneinander operieren und dadurch auch keinen Einfluss aufeinander ausüben.\\
Lediglich der \textit{Beverage-List} Contract löst ein Event aus, sobald eine bestimmte Funktion dessen aufgerufen wird. \\
Die Ausführung (\textit{call}) beider erfolgt jedoch stets von Seiten der \textit{Tablet-App}. Diese ist auch die einzige Instanz, welche in Form von Transaktionen mit der Blockchain interagiert.

\nlparagraph{Tablet-App}
Die \textit{Tablet-App} ist eine mit React-Native \cite{RN:ReactNative} erstellte plattformübergreifende App, welche auf einem Android Tablet installiert ist. Die Hauptaufgabe der App ist es Funktionen der beiden Smart Contracts aufzurufen, in dem es die benötigten Daten an den Smart Contract übergibt, um schlussendlich Transaktionen auszulösen.\\
Damit eine Kommunikation mit einem Smart Contract überhaupt zustande kommt, schickt die App einen Request an den Fileserver, welcher wiederum mit den angefragten Smart Contract Daten in Form einer Datei antwortet.

\nlparagraph{Event}
Das Event beschreibt im Grunde die indirekte Kommunikation zwischen dem \textit{Learner} und der \textit{Tablet-App} mit dem Smart Contract \textit{Beverage-List} als Mittelsmann. So wird jenes im Zuge eines Funktionsaufrufs des Smart Contracts, von Seiten der App ausgelöst, anschließend vom \textit{Learner} detektiert und dessen Inhalt zum Erlernen des Kaffeetrinkverhaltens verwendet.

\subsection{Workflow}
\label{subsec:workflow}
Die unter Kap. \ref{subsec:architecture} beschriebene Architektur wird im folgenden unter dem Gesichtspunkt des Workflows, also dem Zusammenspiel der einzelnen Komponenten und dem Gesamtablauf, näher betrachtet. Dabei beschreibt der Gesamtablauf die einzelnen Schritte, startend beim Setup der Komponenten, hin zum eigentlichen Durchlauf der einzelnen Softwareanwendungen, was letztlich im Erlernen des Kaffeetrinkverhaltens resultiert. Im Zuge dessen werden auch einzelne Algorithmen der Instanzen und Kommandos kurz erläutert, um ein besseres Verständnis für die Funktionsweise der Anwendungen zu bekommen. \\\\
Der Workflow lässt sich in zwei Phasen unterteilen. In der ersten werden die einzelnen Komponenten konfiguriert und gestartet. Die Zweite beschreibt den eigentlichen Ablauf und das Zusammenwirken der Instanzen.

\paragraph{Setup}
\begin{legal}
	\item {Blockchain}
	\begin{legal}
		\item erstellen \& konfigurieren
		\item starten
	\end{legal}
				      	       	                            
	\item Fileserver
	\begin{legal}
		\item REST API starten
		\item UDP Broadcast starten
	\end{legal}
				      	       	                            
	\item Smart Contracts
	\begin{legal}
		\item deploy Beverage-List Smart Contract und sende JSON-File mit \textit{ABI} und Adresse an Fileserver
		\item deploy Coffee-Coin Smart Contract und sende JSON-File mit \textit{ABI} und Adresse an Fileserver
	\end{legal}
				      	       	                            
	\item Learner
	\begin{legal}
		\item Worker starten
		\item Watcher starten
	\end{legal}
				      	       	                            
	\item Tablet App
	\begin{legal}
		\item installieren
		\item starten
	\end{legal}
				      	       	                                
\end{legal}

Die Punkte 1. und 2. sowie 4. und 5. können auch parallel ausgeführt bzw. deren Reihenfolge vertauscht werden.\\\\
Im ersten Schritt muss die private Blockchain erstellt werden. Dabei müssen zuerst die benötigten Accounts generiert und daraufhin die Blockchain erzeugt werden. Sollte 1a) zu einem früheren Zeitpunkt bereits durchgeführt worden sein, kann dieser Punkt übersprungen und gleich mit 1b) begonnen werden.
Sobald 1a) einmal durchgeführt wurde, kann die Blockchain gestartet werden.
\\\\ Dies geschieht mit folgendem Befehl (vgl. \ref{img:geth}):\\

\begin{figure}[hbt!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/geth.png}
	\caption[Geth]{Geth Kommandozeilenbefehl zum starten der Blockchain}
	\label{img:geth}
\end{figure}
% \newlength{\imageheight}
% \settoheight{\imageheight}{\includegraphics{./Abbildungen/Kapitel_03/geth.png}}
% \includegraphics[trim=0 0.49\imageheight{} 0 0, clip, width=.9\columnwidth]{./Abbildungen/Kapitel_03/geth.png}


% \begin{figure}[hbt!]
% 	\centering
% 	\includegraphics[trim=0 0 0 0.503\imageheight{}, clip, width=.9\columnwidth]{./Abbildungen/Kapitel_03/geth.png}
% 	\caption[Geth]{Geth Kommandozeilenbefehl zum starten der Blockchain}
% 	\label{img:geth}
% \end{figure}

Dieser Befehl setzt zum einen weitere Konfigurationsparameter der Blockchain. So wird z.B. festgelegt unter welcher IP-Adresse und Port (\textit{-{}-rpcaddr}, \textit{-{}-rpcport}, \textit{-{}-wscaddr}, \textit{-{}-wsport}) die Blockchain erreichbar ist und welche API-Befehle unter dieser Schnittstelle ausgeführt werden dürfen (\textit{-{}-rpcapi}, \textit{-{}-wsapi}). \\
Zum anderen wird zugleich eine full node gestartet (\textit{-{}-syncmode}), die durch das \quotes{Flag} \textit{-{}-mine} sofort zu minen beginnt.\\
Des Weiteren werden alle Accounts entsperrt, die unter (\textit{-{}-unlock}) gelistet sind und deren Passwörter in der angegebenen Textdatei bei (\textit{-{}-password}) hinterlegt sind. \\\\
Damit eine Node Daten speichern kann, muss ein Verzeichnis angegeben werden (\textit{-{}-datadir}), in welchem Dateien abgelegt werden können. Hier werden z.B. die Daten der Accounts oder auch die Textdatei mit den Passwörtern (\textit{-{}-password}) gespeichert.\\\\
Wurde die Blockchain in Betrieb genommen, wird im nächsten Schritt die REST API und der UDP Broadcast des Fileservers gestartet. \\
Daraufhin ist es möglich die beiden Smart Contracts zu deployen. Dabei wird jeweils für 3a) und 3b) das identische Skript mit unterschiedlichen Eingabeparametern ausgeführt. Dieses Skript liest zuerst die Datei des angegebenen Smart Contracts ein und erzeugt daraufhin die Binaries und die \textit{ABI}, welche schlussendlich verwendet werden ein Go Bindingsfile zu generieren.
Im Anschluss wird ein Go-Skript ausgeführt, welches auf Grundlage des Bindingsfiles den Smart Contract auf der Blockchain installiert und die zurückgelieferte Adresse, sowie die bereits bekannte \textit{ABI} in ein JSON-File packt und an den Fileserver schickt.\\\\
Wurden die Smart-Contracts erfolgreich deployed, kann der Learner gestartet werden. Dieser \quotes{subscribed} sich im ersten Schritt auf den UDP Broadcast und extrahiert aus den Nachrichten die IP-Adresse der Blockchain und des Fileservers. Anschließend werden sowohl der \textit{Worker} als auch der \textit{Watcher} in Form von \quotes{Goroutines} (nebenläufige Kindprozesse) aktiviert. Der \textit{Worker} iteriert über die Liste aller User und kontaktiert jeweils den Fileserver, ob bereits gelernte Daten für diesen User vorhanden sind. Sollte das Fall sein, initialisiert er damit die Parameter des Q-Learning Algorithmus des jeweiligen Users.\\
Der \textit{Watcher} schickt ebenfalls eine Anfrage an den Fileserver und bekommt als Antwort die Daten der Smart Contracts. Daraufhin kann er sich mit der Blockchain verbinden und sich auf die Events des \textit{Beverage-List} Smart Contracts subscriben.\\\\
Abschließend wird die App auf dem Tablet installiert, sollte sich diese noch nicht auf dem Tablet befinden und daraufhin gestartet. Die Initialisierung erfolgt hierbei nach dem selben Prinzip wie beim Learner. Zuerst wird der UDP Broadcast nach der Server Adresse abgefragt, mit welcher anschließend der Request an den Fileserver geschickt wird, um die benötigten Smart Contract Daten zu bekommen. Im Anschluss werden jene verwendet eine Verbindung zur Blockchain bzw. zu den Smart Contracts herzustellen.
\\\\
Erfolgte eine fehlerlose Abarbeitung dieser Schritte, kann zum eigentlichen Workflow übergegangen werden.
\clearpage
\paragraph{Workflow}
\begin{legal}
	\item {App}
	\begin{legal}
		\item User wählt Getränk aus
		\item \textit{call} Coffee-Coin
		\item \textit{call} Beverage-List
	\end{legal}
				      	       	                            
	\item Smart Contracts
	\begin{legal}
		\item Beverage-List \textit{triggers} Event
	\end{legal}
				      	       	                              
	\item Learner
	\begin{legal}
		\item Watcher:
		\begin{legal}
			\item detektiert Event
			\item extrahiert Daten aus Event
			\item \quotes{befüllt} Q-Learning Algorithmus mit den Event-Daten (evaluate \& predict)
		\end{legal}
		\item Worker (periodisch alle 3h)
		\begin{legal}
			\item \quotes{triggers} Q-Learning Algorithmus (\textit{evaluate} \& \textit{predict})
			\item sendet gelernte Daten an Fileserver
		\end{legal}
	\end{legal}
\end{legal}

Diese Auflistung beschreibt einen synchronen, erfolgreichen Durchlauf der Systemarchitektur - die Asynchronität des Workers 3b) außer Acht gelassen. Alternative Abläufe sowie Zustände die aus Fehlern resultieren, werden bei den einzelnen Komponenten nochmals genauer betrachtet.\\\\
Der Workflow wird durch den User angestoßen, indem dieser auf dem Tablet ein Getränk auswählt und eine Transaktion auslöst. Zuerst wird dabei der \textit{Coffee-Coin} Contract aufgerufen und das ausgewählte Getränk bezahlt. Nachdem diese Transaktion erfolgreich bestätigt wurde, wird als nächstes der \textit{Beverage-List} Contract ausgeführt. Die dabei aufgerufene Funktion des Smart Contracts verwendet die übergebenen Daten (Zeit, Getränk, Wochentag, Ethereum-Adresse) und löst damit ein Event aus. \\
Dieses Event wird vom \textit{Watcher} detektiert und die Daten (Zeit, Getränk, Wochentag, Ethereum-Adresse) daraus extrahiert. Daraufhin wird die \quotes{Learn-Methode} des Q-Learning Algorithmus aufgerufen, bei der zuerst die vorherige \textit{Prediction} evaluiert und basierend auf dem aktuellen Zustand eine neue \textit{Prediction} gemacht wird. \\
Zu diesem synchronen Durchlauf führt der Worker am Ende jedes Timeslots (alle 3h) die Learn-Methode für jeden bekannten User aus. Das heißt es werden wie auch beim Watcher die Predictions des vorangegangen Timeslots evaluiert, neue Predictions für den kommenden Timeslot erstellt und die gelernten Daten als Datei an den Fileserver gesendet.


\section{Blockchain}
\label{sec:bchain}

Das folgende Kapitel erläutert im Detail den Setup der privaten Blockchain, sowie die beiden Smart Contracts, welche ebenso einen Teil der Systemarchitektur darstellen.

\subsection{Genesis Block}
\label{subsec:genesis}
Der große Vorteil einer privaten (Ethereum) Blockchain gegenüber einer öffentlichen, ist die Möglichkeit die Blockchain nach den eigenen Vorstellungen und Anwendungszwecken zu konfigurieren. So können, wie auch bei einer öffentlichen Blockchain, Smart Contracts erstellt und Transaktionen durchgeführt werden, allerdings ohne dabei wirkliches Ether zu besitzen. Denn eine Besonderheit eines sogenannten \quotes{Testnets} ist das Erzeugen von privatem Ether, welches Accounts zugeordnet und Transaktionen damit durchgeführt werden können \cite{Bchain:PubVsPrivate}.\\
Die Konfiguration dessen erfolgt durch ein \textit{genesis.json file} (\ref{img:gen}). Diese Datei ist die Grundlage für den \textit{Genesis Block} der zu erstellenden Blockchain, welcher der erste Block in der Kette ist und somit auch keinen Vorgänger besitzt \cite{MasteringBlockchain}.\\\\
Das in \ref{img:gen} abgebildete JSON Objekt zeigt die in der Systemarchitektur verwendete Datei einen solchen \textit{Genesis Block} zu erzeugen. Nicht alle \quotes{properties} bedingen einer Erklärung, die essentiellen werden in Folge kurz erläutert \cite{MasteringBlockchain, Eth:GenFile}: 
\newpage
\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/genesis.json.png}
	\caption[genesis.json]{JSON-File zur Generierung des Genesis Blocks}
	\label{img:gen}
\end{figure}

\begin{itemize}
	\item[-] chainId: ist eine einzigartige Id für die private Blockchain
	      	      	      	      
	\item[-] eip150Block/eip155Block/eip158Block: eip steht für \quotes{Ethereum Improvement Proposal}. Diese drei Community getriebenen \quotes{Proposals} beschreiben sog. \quotes{hard forks}, welche dafür sorgen sollen, Fehler im Protokoll zu beheben. 
	      	      	      	      
	\item[-] homesteadBlock: Homestead ist die zweite \quotes{major version} von Ethereum, welche einige Änderungen an dem Protokoll vornahm
	      	      	      	      	
	\item[-] difficulty: beschreibt die Schwierigkeitsstufe für einen Miner einen validen Block zu finden. Das heißt, je höher der Wert desto mehr Berechnungen müssen statisch durchgeführt werden und desto mehr Zeit wird benötigt, um eine Transaktion zu bestätigen. Im Falle einer privaten Blockchain ist es deshalb ratsam einen sehr niedrigen Wert zu wählen
	      	      	      	      	
	\item[-] gasLimit: beschreibt das Limit für eine Transaktion wie viel an Gas verbraucht werden darf. 
	      	      	      	      
	\item[-] alloc: hier können Accounts schon im Voraus mit \quotes{fake ether} befüllt werden.
	\item[-] nonce: ist ein Zähler für die Anzahl der durchgeführten Transaktionen einer Adresse
\end{itemize}

Sobald die genesis.json Datei fertiggestellt ist, kann die Blockchain mit folgendem Befehl erstellt werden (vgl. Abbildung \ref{img:gethInit}):\\
\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/geth-init.png}
	\caption[geth init]{Kommandozeilenbefehl zur Generierung des Genesis Blocks}
	\label{img:gethInit}
\end{figure}

%\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/geth-init.png}

Das Flag \textit{-{}-datadir} ist mit dem aus Abbildung \ref{img:geth} identisch. Das bedeutet das Verzeichnis, welches hier im Befehl angegeben ist, muss beim Kommandozeilenbefehl in Abbildung \ref{img:geth} exakt gleich sein. Andernfalls ist es nicht möglich die Blockchain zu starten.\\\\
Nachdem der Setup der privaten Blockchain abgeschlossen ist, kann mit der Entwicklung eines Smart Contracts begonnen werden.\cite{Eth:Guide} \\\\
Die nächsten beiden Unterkapitel befassen sich mit den Smart Contracts, die im Zuge der Arbeit entwickelt wurden.

\subsection{Coffee-Coin}
\label{subsec:cc}
Der Smart Contract \textit{Coffee-Coin} stellt einen sogenannten \textit{ERC-20 Token} mit gewissen Abwandlungen dar. Dabei ist ein Token im Grunde ein zusätzliches Zahlungsmittel zur eigentlichen Währung von Ethereum dem Ether. Das bedeutet Smart Contracts können somit eine eigenständige Währung abbilden. Für solche Smart Contracts gibt es mittlerweile einige Standardisierungen, die Vorschreiben welche Methoden und Datenstruktur ein Smart Contract zu implementieren hat. Der am weitesten verbreitete Standard ist der \textit{ERC-20} \cite{ERC:Wiki, ERC:Github, ERC:BlockGeeks}, bei welchem es folgende Funktionen und Events zu implementieren gilt (vgl. Abbildung \ref{img:ERC}):

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/erc20.png}
	\caption{ERC-20 Interface}
	\label{img:ERC}
\end{figure}

\begin{itemize}
	\item totalSupply: Gesamtanzahl der existierenden Tokens
	\item balanceOf: Anzahl der Tokens eines bestimmten Users
	\item allowance: besagt wie viele Tokens eines bestimmten Users durch einen bestimmten \quotes{spender} abgehoben werden dürfen
	\item transfer: transferiert die Inputanzahl an Tokens des \quotes{senders} (Adresse welche diese Funktion aufgerufen hat) an die angegebene Adresse
	\item approve: Erlaubniserteilung an den \quotes{spender} die in \textit{allowance} festgelegte Anzahl an Tokens abzubuchen
	\item transferFrom: transferiert die angegebene Anzahl von Tokens von der \quotes{from Adresse} zur \quotes{to Adresse}
	\item event Transfer: wird von den beiden \textit{transfer} Funktionen ausgelöst
	\item event Approval: wird von der \textit{approve} Funktion ausgelöst
\end{itemize}

Der eben erläuterte Token Standard, wurde im Falle des Coffee-Coin Smart Contracts um zusätzliche Funktionen und Datenstrukturen erweitert. Diese Erweiterungen stellen eine gesonderte Abstraktionsebene nach außen hin da, um die Kommunikation seitens der Tablet-App zu erleichtern und einfacher zu gestalten.\\
So werden schon beim Deployment die einzelnen Preise der Getränke und die Adresse, zu jener die Tokens beim Bezahlen eines Getränks überwiesen werden, gesetzt.\\
Dies ermöglicht die Implementierung folgender Funktionen (vgl. Abbildung \ref{img:cci}): 

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/CCInterface.png}
	\caption{Coffee-Coin Interface Auszug}
	\label{img:cci}
\end{figure}

Diese Funktionen bieten eine Abstraktionsebene zur ERC-20 Funktion \textit{transferFrom}. Da bereits beim Deployment die Parameter für die Getränke und die Zieladresse gesetzt werden, benötigen diese Funktionen keine weiteren Daten von der Seiten der User (Tablet-App). Somit kann nach Auswahl des Getränks, die entsprechende Funktion aufgerufen werden, ohne sich dabei mit den Details der Transaktion beschäftigen zu müssen.\\\\
Des weiteren wird einem User, beim ersten Aufruf einer jener Funktionen (erste ausgelöste Transaktion des Users), eine festgelegte Anzahl an Tokens als \quotes{Startguthaben} überwiesen, sodass dieser stets über genügend Token verfügt und jederzeit Transaktionen durchführen kann.\\
Im Kontext der Problemstellung liegt die Zweckmäßigkeit des Smart Contracts grundsätzlich in der Bezahlung der Getränke in Form des Tokens. Dabei wird vor allem die Möglichkeit einer solchen Bezahlmethode aufgezeigt, weswegen Transaktionen lediglich auf exemplarischer Ebene durchgeführt werden. Das bedeutet, den Usern wird, wie gerade beschrieben, eine nahezu unendliche Menge an Tokens zugewiesen ohne eine Gegenleistung zu fordern.

\subsection{Beverage-List}
\label{subsec:bl}

Im Gegensatz zur \textit{Coffee-Coin} basiert der \textit{Beverage-List} Contract auf keinem festgelegten Standard, sondern ist in voller Gänze an die Problemstellung angepasst.\\
Dessen Zweck besteht im Grunde darin eine Getränkeliste abzubilden, in welcher jede Getränketransaktion eines Users vorzufinden ist. Dabei wird pro Transaktion nicht nur das Getränk, sondern auch das aktuelle Datum inklusive Uhrzeit und der aktuelle Wochentag gespeichert. Diese Daten sollen es dem Learner schlussendlich ermöglichen das Kaffeetrinkverhalten des Users zu erlernen. \\
Damit der Learner ohne großen Aufwand auf die Informationen zugreifen kann, löst der Smart Contract, mit den eben genannten Daten beinhaltend, ein Event aus, sobald seine Methode \quotes{setDrinkData} aufgerufen wird. Die Funktion hinterlegt die übergebenen Daten (Ethereum-Adresse, Zeit, Wochentag, Getränk) in der festgelegten Datenstruktur und löst zugleich das Event für den Learner aus.\\\\
Dieser Smart Contract umfasst noch weitere Funktionen, welche aber vor allem zu Testzwecken implementiert wurden und in der finalen Systemarchitektur keine Verwendung finden. 

\newpage
\section{Learner}
\label{sec:ql}
Als nächstes wird der \textit{Learner} detailliert betrachtet. Dabei wird zuerst die Problemstellung hinsichtlich des Reinforcement-Learnings modelliert und im Anschluss der verwendete Algorithmus (Q-Learning) allgemein und im Kontext der Problemstellung erläutert.

\subsection{Modellierung}
\label{subsec:modulation}
Die Modellierung eines Lernproblems, im Hinblick auf einen Reinforcement-Algorithmus, erfolgt in der Regel stets nach der selben Systematik. \\
Zuerst werden der Zustandsraum (alle möglichen Zustände), alle Aktionen des \textit{Agenten} und der \textit{Reward} für ausgeführte Aktionen eruiert.
Hier ist in diesem Fall ist der Agent der Lerner-Instanz, welche das Kaffeetrinkverhalten der User zu erlernen versucht.\\\\
Die Modellierung sieht wie folgt aus: 
\paragraph{Zustandsraum}
\begin{itemize}
	\item Wochentag: Montag, Dienstag, Mittwoch, Donnerstag, Freitag
	\item Timeslot:
	      \begin{itemize}
	      	\item 7-10 Uhr (T0)
	      	\item 10-13 Uhr (T1)
	      	\item 13-16 Uhr (T2)
	      	\item 16-19 Uhr (T3)
	      	\item 19-7 Uhr (T4)
	      \end{itemize} 
	\item Kafee-Anzahl: n $*$ Kaffee (n=Anzahl pro Tag)
\end{itemize}

\paragraph{Aktionen}
\begin{itemize}
	\item Kaffee
	\item Nothing
\end{itemize}

\paragraph{Reward}
\begin{itemize}
	\item +1 bei richtiger Prediction
	\item \textminus 1 bei falscher Prediction
\end{itemize}
\ \\
Daraus lässt sich folgender exemplarischer Zustand konstruieren: 
\begingroup
\makeatletter
\@totalleftmargin=-0.5cm
\begin{Verbatim}
	< Wochentag: Montag; Timeslot: 2; Kaffee-Anzahl: 3 >
\end{Verbatim}
\endgroup
Das bedeutet konkret: an einem Montag wurden einschließlich des 2. Timeslots (13-16 Uhr) 3 Kaffee getrunken. Dieser Status gibt jedoch keinen Aufschluss darüber, welcher sein Vorgänger war und welcher sein Nachfolger sein wird. So können einerseits alle Kaffees nur in Timeslot 2 getrunken worden sein oder in jedem Timeslot (0,1,2) jeweils einer. Andererseits besteht auch die Möglichkeit, dass in Timeslot 2 nochmals ein Kaffee konsumiert wird oder eben erst in einem nachfolgendem Timeslot.\\\\
Dieses Lernproblem ist auch als \textit{Multi-Armed Bandit Problem} bekannt und wird in Kap. \ref{subsec:y-ql} erläutert.
\\\\
Der erste Modellierungsansatz sah anstatt der Kaffee-Anzahl eine Getränkeanzahl vor, bei der zum Kaffee auch die Quantität der getrunkenen Club Mate und Wasser berücksichtigt werden sollten. Der Grund dafür liegt in dem erheblichen Einfluss des Konsums weiterer Getränke auf das Kaffeetrinkverhalten, wodurch mit solch einer granularen Modellierung genauere Predictions zu erwarten sind. Jedoch steigt somit auch die Anzahl der zu durchlaufenden Zustände und einhergehend die zu erlernenden optimalen Aktionen für die Zustandsübergänge. Letztlich resultiert dies in der längeren Trainingsphase des Algorithmus, was aber aufgrund des zeitlich begrenzten Rahmen dieser Arbeit nicht durchführbar war und deshalb der Ansatz mit lediglich der Kaffee-Anzahl gewählt wurde.

\subsection{Q-Learning}
\label{subsec:y-ql}
Der Q-Learning Algorithmus fällt unter die Methodik des \textit{TD-Learning} (vgl. \ref{subsec:rl}). Der Algorithmus wartet aus diesem Grund nicht bis zur Terminierung einer Episode, um die Wertfunktion zu schätzen, sondern berechnet diese im nächsten Zeitschritt. Im Gegensatz zu anderen TD-Learning Algorithmen bemisst die Wertfunktion des Q-Learning nicht den aktuellen Zustand, sondern  beurteilt die Aktion in diesem Zustand. Hierbei wird von der Aktion-Wert Funktion \textit{Q} gesprochen \cite{Sutton}.\\\\
Die Berechnung von \textit{Q} erfolgt nach folgender Formel (\ref{eqn:qval}):
\begin{equation} \label{eqn:qval}
	Q(s_t,a_t)\;\leftarrow\;Q(s_t,a_t) + \alpha [ r_{t+1} + \gamma \max_a
	Q(s_{t+1},a) - Q(s_t,a_t) ]
\end{equation}
\begin{itemize}
	\item Q(s\textsubscript{t},a\textsubscript{t}): beschreibt den aktuellen \textit{Q-Wert} bzw. \textit{Q-Value} der Aktion a welche zum Zeitpunkt t im Zustand s ausgeführt wurde
	\item \textalpha: wird als Lernrate bezeichnet und gibt an in welchem Maße der alte Q-Value durch den Neuen überschrieben wird
	\item r\textsubscript{t+1}: ist der Reward zum Zeitpunkt t+1, nachdem im Zustand s die Aktion a ausgeführt worden ist
	\item \textgamma: ist der Diskontierungsfaktor und wird als Gewichtung für zukünftige Rewards verstanden 
	\item \textunderset{a}{max}Q(s\textsubscript{t+1},a\textsubscript{t}): ist das Maximum an Reward, der durch die Ausführung der Aktion a' im neuen Zustand s' erfolgt
\end{itemize}

Abgespeichert werden diese Q-Values in der sogenannten Q-Tabelle (vgl. Tabelle \ref{table:qtable}), hierbei gibt es ein 1:1 Mapping von jeweils einem Zustand auf jeweils eine Aktion. 

\begin{table}[h!]
	\begin{center}
		\caption{Exmplarische Q-Tabelle}
		\begin{tabular}{| l | l | l | l |}
			\hline
			    & a1  & a2   & a3  \\ \hline
			s1  & 0.1 & -0.2 & 1.2 \\ \hline
			s2  & 0.4 & -0.5 & 0.8 \\ \hline
			s3  & 1.1 & -0.3 & 0.7 \\ \hline
			... & ... & ...  & ... \\ \hline
		\end{tabular}
		\label{table:qtable}
	\end{center}
\end{table}

Die Anwendung und der Ablauf wird anhand des Pseudocodes in Algorithmus \ref{ql-psc} abgebildet.

\begin{algorithm}
	\caption{Q-learning algorithm}
	\label{ql-psc}
	\begin{algorithmic}[1]
		\State Initialize Q(s,a), for all s \textepsilon S,a \textepsilon A(s) and Q(terminal-state,·) = 0
		\Repeat (for each episode):
		\State Initialize s
		\Repeat (for each episode):
		\State Choose A from s using policy derived from Q (e.g., greedy)
		\State Take action A, observe R, s'
		\State $Q(s_t,a_t)\;\leftarrow\;Q(s_t,a_t) + \alpha [ r_{t+1} + \gamma \textunderset{a}{max}
		Q(s_{t+1},a) - Q(s_t,a_t) ]$
		\State s $\leftarrow $ s' 
		\Until s is terminal
	\end{algorithmic}
\end{algorithm}

Zum Start wird der Q-Table initialisiert, indem jedes Feld eines Zustand-Aktions-Paars auf '0' gesetzt wird. Im Anschluss wird ein Durchlauf mit einer bestimmten Anzahl an Episoden gestartet. Hierbei wird zunächst der aktuelle Zustand initialisiert bzw. beobachtet und daraufhin eine weitere Schleife betreten, welche solange durchlaufen wird bis der Zustand \textit{s}  terminiert. Als nächstes wird eine Aktion \textit{a}  anhand der aktuellen Strategie ausgewählt. Diese Aktion wird ausgeführt und der resultierende Reward, sowie der neue Zustand werden detektiert. Anhand dieser Beobachtung wird mit der Formel (vgl. \ref{eqn:qval}) der neue Q-Value berechnet und die Q-Tabelle upgedatet. Zum Schluss wird der neue Zustand \textit{s'} als der 
aktuelle Zustand \textit{s} gesetzt und eine neue Iteration beginnt \cite{Sutton, mlmitchel, MultiagentSystems}. \\\\
Der gerade eben beschriebene Algorithmus findet sich in einer abgewandelten Form (vgl. Gleichung \ref{eqn:bandit}) in der Implementierung des Learners wieder. So wird eine Aktion nicht immer nach dem greedy-Prinzip der Reward-Maximierung ausgewählt, sondern nach der Methodik des \textit{\textepsilon}-greedy. Dabei beschreibt die Variable \textit{\textepsilon} einen Wert zwischen '0' und '1' und gibt dadurch das Verhältnis zwischen Exploration und Exploitation an - in der Regel ist der Wert von \textit{\textepsilon} eher klein. \\
So wird im Falle von \textit{\textunderset{a}{max}Q} stets die Aktion \textit{a} ausgeführt, welche in Zustand s den größten Reward verspricht - auch als greedy Strategie bekannt. Bei \textit{\textepsilon}-greedy jedoch, wird zu einem gewissen Anteil - definiert durch das \textit{\textepsilon} - nicht immer die Aktion ausgewählt, die den größten Reward verspricht. Sondern ist wird zufällige Selektion einer Aktion durchgeführt,  obgleich des erwarteten Rewards. Somit wird eine Erforschung des Zustandsraums durch den Lernagenten sichergestellt und eine Beschränkung auf lediglich bekannte Aktionen und Zustände vermieden. \\
Eine Besonderheit der Implementierung liegt in der Vakanz der Berücksichtigung von Folgezuständen bei der Berechnung des Q-Values.
\begin{equation} \label{eqn:bandit}
		Q(s_t,a_t)\;\leftarrow\;Q(s_t,a_t) + \alpha [ r_{t+1} - Q(s_t,a_t) ]
\end{equation}

Aufgrund der Interdependenz der Zustände, ist das Verfolgen einer Strategie und das Einbeziehen der Folgezustände in die Berechnung der Q-Werte nicht notwendig. Der Fokus wird dadurch nur auf den Zustand als solches gelegt und die Annäherung des \quotes{wahren} Q-Wertes indessen einzig anhand des Rewards r\textsubscript{t+1} durchgeführt. \\
Eine solche Form der Problemstellung wird auch als \textit{n-armiges Bandit Problem} bezeichnet. Dieses ist ein klassisches Problem des Reinforcement Learning, welches das Dilemma zwischen Exploration und Exploitation aufdeckt. Es beschreibt das Spielen an mehreren (n) Glücksspielautomaten, deren einzige Aktion die Betätigung des Hebels ist. Das Ziel das Spielers ist die Maximierung seiner Belohnung (Exploitation) und wird deswegen nach jeder Aktion vor die Entscheidung gestellt, ob der Wechsel zu einem anderen Automat einen größeren Gewinn für ihn bedeutet (Exploration) oder ob er den aktuellen beibehält. \\\\
Die Analogie zum Lernproblem besteht in der Abbildung des unmittelbaren Rewards auf die gewählte Aktion. Eine Aktion wird nie angesichts von nachfolgenden Aktionen bewertet, sondern einzig anhand der Belohnung nach ihrer Ausführung. Außerdem handelt es sich in beiden Fällen um ein nichtdeterministisches Lernproblem, bei welchem die Ausführung einer Aktion in einem bestimmten Zustand stets einen Reward bezüglich einer Wahrscheinlichkeitsverteilung nach sich zieht und somit eine hundertprozentige Vorhersage der zu erhaltenden Belohnung nicht möglich ist \cite{Sutton}.

% \newpage
\subsection{Lernprozess \& Ablauf}
\label{subsec:learning}

Aufgrund der Modellierung eines Zustandes ergeben sich zwei Arten bei denen eine Änderung dessen hervorgerufen wird: 
\begin{itemize}
	\item durch eine zeitliche Komponente, bei der sich entweder der Timeslot oder der Tag ändert
	\item durch den User indem er eine Transaktion auslöst
\end{itemize}

Das ist in dieser Hinsicht von großer Bedeutung, da für diese Übergänge ein Feedback für den Agenten notwendig ist, um die optimale Aktion dafür zu erlernen. \\
So wird das Feedback einerseits von Seiten des Users in Form einer bestätigten Transaktion generiert, was bedeutet Aktion \quotes{Kaffee} wurde ausgeführt. Oder andererseits als Folge einer fehlenden Rückmeldung des Nutzers, welche \quotes{Nothing} als optimale Aktion impliziert. \\
Das heißt, erfolgt eine Zustandsänderung durch den User, so ist stets \quotes{Kaffee} die zu erlernende, beste Aktion. Wird eine Zustandsänderung durch einen Timeslotwechsel bewirkt, so ist das Feedback der Umgebung immerfort die Aktion \quotes{Nothing}. \\
Um dem Agenten bzw. dem Q-Learning Algorithmus stets das nötige Feedback zu geben und Zustandsübergänge herbeizuführen, werden im Learner die Komponenten \textit{Watcher} und \textit{Worker} verwendet. \\
Der \textit{Watcher} ist dafür zuständig das Feedback des Users durch das \textit{Beverage-List-Event} zu detektieren und die darin enthaltenen Daten dem Algorithmus zur Verfügung zu stellen. \\
Hierbei gilt es zu erwähnen, dass der \textit{Watcher}, aufgrund der definierten Felder im Event, lediglich eine Feature Extraction durchführen muss und aus diesem Grund auf eine Feature Selection verzichtet werden kann \cite{fteng}.\\\\ 
Der \textit{Worker} wird für die zeitliche Komponente verwendet, indem er am Ende jedes Timeslots aktiv wird, die Zustandsänderung durchführt und dem Agenten die Aktion \quotes{Nothing} als Feedback gibt. \\
Auf Basis dieser Feedbacks wird es dem Q-Learning Algorithmus ermöglicht die optimalen Aktionen zu erlernen. Hierbei wird die Prediction, also die aus Sicht des Agenten beste Aktion für den Zustandsübergang, anhand der Rückmeldung, sei es durch den \textit{Watcher} oder \textit{Worker}, evaluiert und für den nächsten Übergang eine neue Aktion eruiert. \\
Dieses Prinzip der Evaluierung und Vorhersage der Aktion kann im Kontext des Lernproblems jedoch nicht kontinuierlich angewendet werden. 
So bedingen bestimmte Zustände nur eine Evaluierung oder nur eine Vorhersage, hingegen nie beides. Der Grund hierfür liegt in der Abgeschlossenheit der Tage als Lernabschnitt, welche komplett unabhängig voneinander agieren. \\
Zudem werden die Uhrzeiten 19 bis 7 Uhr (T4) nicht in der Zustandsraummodiellerung berücksichtigt, da in diesem Zeitraum keine Aktion durch den User zu erwarten ist.\\ 
Dies hat für den \textit{Worker} zur Folge, dass zum einen am Anfang jeden Tages bzw. beim Wechsel von T4 auf T0, lediglich eine Vorhersage für den nächsten Zustandsübergang gemacht und zum anderen am Ende von T3 einzig die letzte Vorhersage evaluiert werden muss.\\\\
% \newpage
Dies lässt sich veranschaulicht folgendermaßen darstellen:
\begin{itemize}
	\item Evaluierung \& Vorhersage: 
	      \begin{itemize}
	      	\item User führt Transaktion durch
	      	\item Timeslot wechselt
	      \end{itemize}
	\item Evaluierung:
	      \begin{itemize}
	      	\item am Ende von T3
	      \end{itemize}
	\item Vorhersage:
	      \begin{itemize}
	      	\item am Anfang von T0
	      \end{itemize}
\end{itemize}    

\newpage
\section{Tablet-App}
\label{sec:app}

Das folgende Unterkapitel befasst sich mit dem Aufbau und der Funktionsweise der App und schildert zudem den verwendeten Algorithmus, welcher die Getränke- und Userdaten auf die Blockchain schreibt.\\\\
Die entwickelte App basiert auf dem Framework ReactNative \cite{RN:ReactNative}, dieses erlaubt es mit einer einzigen Codebasis Apps für unterschiedliche Plattformen (z.B. iOS, Android) zu entwickeln. Der wesentliche Vorteil allerdings liegt in der Verfügbarkeit einer offiziellen Library, mit der es erst möglich ist, eine Verbindung zur Blockchain bzw. den Smart Contracts herzustellen. Jene Library (Web3.js) wurde von Ethereum entwickelt, um sogenannte DApp's auf Basis von Javascript erstellen zu können. \\
So ist die Entwicklung einer DApp in einer nativen Programmiersprache (Java/Kotlin/Swift) bisher nur mit \quotes{third-party} Libraries möglich, weswegen die Umsetzung letztlich mit ReactNative erfolgte.

\subsection{Interface}
\label{subsec:interface}
Eine essentielle Eigenschaft von ReactNative ist der komponentenbasierte Ansatz. Dabei setzt sich eine App aus vielen einzelnen Komponenten zusammen, welche jeweils einen dedizierten Aufgabenbereich abdecken. \\
Im Falle der entwickelten App existieren jeweils zwei \quotes{page components}, die wiederum mehrere kleine Komponenten in sich vereinen. 
Da es aber den Rahmen dieser Arbeit sprengen würde auf jede einzelne Komponente und deren Funktionsweise einzugehen, werden nur die Hauptkomponenten anhand ihrer Funktion und Bedienung geschildert. \\\\
Wird die App gestartet und es besteht eine Verbindung zum Internet, so findet der User folgende Startseite (vgl. Abbildung \ref{img:emps1}) vor.

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/emps1.png}
	\caption{Mitarbeiter Page: kein Mitarbeiter ausgewählt}
	\label{img:emps1}
\end{figure}

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/emps2.png}
	\caption{Mitarbeiter Page: Mitarbeiter ausgewählt}
	\label{img:emps2}
\end{figure}

Hier kann der User seinen Avatar selektieren und deselektieren. Ist ein Avatar ausgewählt wird der \quotes{NEXT} Button aktiviert (vgl. Abbildung \ref{img:emps2}) und durch dessen Betätigung gelangt der User zur nächsten Seite (vgl. Abbildung \ref{img:drinks1}): 

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/drinks1.png}
	\caption{Drinks Page: kein Getränk ausgewählt}
	\label{img:drinks1}
\end{figure}

Hier besteht eine Auswahl aus folgenden Getränken: Club Mate, Wasser und Kaffee. 
Ausgewählt kann jedoch immer nur eines werden (vgl. Abbildung \ref{img:drinks2}).\\
Das Prinzip der Selektion und Deselektion ist identisch mit dem der vorherigen Seite. So wird der \quotes{SUBMIT} Button aktiv, sobald ein Getränk ausgewählt ist und inaktiv wenn das Getränk wieder deselektiert wird (vgl. Abbildung \ref{img:drinks1}).

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/drinks2.png}
	\caption{Drinks Page: Getränk ausgewählt}
	\label{img:drinks2}
\end{figure}

Wird schließlich der \quotes{SUBMIT} Button gedrückt und die Transaktion als erfolgreich bestätigt erscheint folgendes Overlay (vgl. Abbildung \ref{img:Overlay}):

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/cheers.png}
	\caption{Overlay: Bestätigung der Transaktion}
	\label{img:Overlay}
\end{figure}

Nach 4 Sekunden wird dieses Overlay wieder ausgeblendet und automatisch zur Startseite (vgl. Abbildung \ref{img:emps1}) navigiert, wodurch der Workflow von neuem startet.\\\\
Aufgrund der Tatsache, dass die Verbindung zum Uni-Netzwerk (eduroam) nur über einen Workaround hergestellt werden konnte, bei dem die Verbindung zum Netzwerk trotz dessen nach einer unbestimmten Zeit immer wieder abgebrochen ist, wurde eine weitere Komponente entwickelt.

\begin{figure}[th!]
	\centering
	\includegraphics[width=.9\columnwidth]{./Abbildungen/Kapitel_03/noconnection.png}
	\caption{No Internet: keine Internetverbindung verfügbar}
	\label{img:drinks2}
\end{figure}

Diese wird sofort eingeblendet, sobald die Verbindung zum Internet unterbrochen ist, allerdings nur wenn sich der User auf der Startseite befindet. \\
Wird die Seite mit den Getränken angezeigt, so wird dem User die Möglichkeit gegeben seine Transaktion abzuschließen. Da in diesem Moment jedoch keine Verbindung zur Blockchain hergestellt werden kann, werden die Transaktionsdaten zwischengespeichert und diese durchgeführt, sobald wieder eine Verbindung zum Netzwerk besteht (vgl. Kap. \ref{subsec:internalFlow}).\\
Die Loading Animation sowie das \quotes{No Internet Connection} Label werden wieder ausgeblendet, sobald die App eine erneute Verbindung zum Uni-Netzwerk detektiert.

\subsection{Internal Workflow}
\label{subsec:internalFlow}
Basierend auf der Problematik eines unerwarteten Verbindungsabbruchs und dem einhergehenden Verlust von essentiellen Lerndaten, wird im folgenden der implementierte Algorithmus geschildert, der dieser Komplikation entgegenwirkt. 

\begin{legal}
	\item Initialisierungsphase:
	\begin{legal}
		\item \quotes{GET} Smart Contract Daten von Fileserver
		\item Initialisierung Web3.js
		\item Wiederhole für jedes Transaktionsfile:
		\begin{legal}
			\item Transaktion durchführen
			\item bei \quotes{Success} Transaktionsdatei löschen
		\end{legal}
	\end{legal}
	\item Warten auf Usereingabe:
	\begin{legal}
		\item User ausgewählt $\rightarrow$ Ethereum-Adresse
		\item Getränk ausgewählt $\rightarrow$ Getränk
		\item Submit $\rightarrow$ (Getränk \& Ethereum-Adresse)
	\end{legal}
	\item Wiederhole für jedes User-Transaktionsfile:
	\begin{legal}
		\item Transaktion durchführen
		\item bei \quotes{Success} Transaktionsdatei löschen\\\\
	\end{legal}
	\item Generierung Transaktionsdaten:
	\begin{itemize}
		\item Gas Estimate, Datum (inkl. Zeit), Wochentag 
		\item Ethereum-Adresse \& Getränk aus 2.3
	\end{itemize}
	\item Transaktion starten:
	\begin{legal}
		\item Erstellung der Transaktionsdatei
		\item Transaktion durchführen
		\item bei \quotes{Success} Transaktionsdatei löschen
		\item gehe zu 1.
	\end{legal} 	
\end{legal}

Der interne Workflow beginnt mit der Initialisierungsphase, hierbei werden zuerst die Smart Contract Files vom Fileserver runtergeladen und mit den beinhaltenden Daten das Web3.js Modul initialisiert. Somit besteht eine Verbindung zu den Smart Contracts und es kann im Anschluss über alle vorhandenen Transaktion Files iteriert werden. \\
Indessen wird zuerst der Coffee-Coin Contract und dann der Beverage-List Contract aufgerufen. Wenn beide ihre Transaktionen bestätigt haben, wird die Datei gelöscht, andernfalls bleibt sie bestehen. Dies geschieht noch bevor der User das Interface zu Gesicht bekommt.\\\\
Nachdem 1.) abgeschlossen ist, wird auf die Eingabe des Users gewartet. Wählt dieser einen Avatar aus und bestätigt mit \quotes{NEXT}, wird seine hinterlegte \textit{Ethereum-Adresse} temporär gespeichert. Wird dann im Anschluss ein Getränk selektiert und \quotes{SUBMIT} gedrückt, werden die Ethereum-Adresse und das Getränk an das interne Blockchain-Modul weitergereicht und die Transaktion gestartet. \\
Dabei wird erneut über die Transaktionsdaten iteriert, allerdings nur über die des Users. Damit soll stets die richtige Reihenfolge der konsumierten Getränke sichergestellt werden, da dies ansonsten auf Seiten des Q-Learning Algorithmus zu falschen Lerneffekten führen würde.\\
Daraufhin kann mit der Generierung der fehlenden Transaktionsdaten angefangen werden. Zuerst wird ein \textit{Gas Estimate} für beide Smart Contract Transaktionen durchgeführt. Dies ist, wie der Name bereits impliziert, eine grobe Schätzung darüber, wie viel Gas beim Funktionsaufruf eines Smart Contracts benötigt wird. \\
Abschließend wird das \textit{Datum} (inkl. Zeit in Sekunden) und der \textit{Wochentag} ermittelt und alle benötigten Daten an die jeweiligen Smart Contract Funktionsaufrufe übergeben. Im Falle des Smart Contracts Beverage-List sind es folgende Parameter: \textit{Gas-Estimate, Datum, Wochentag, Ethereum-Adresse, Getränk}.\\
\noindent Bei Coffee-Coin wird anhand des Getränks die entsprechende Smart Contract Funktion ausgewählt und lediglich das \textit{Gas-Estimate} und die \textit{Ethereum-Adresse} des Users übergeben.\\
Bevor jedoch beide Transaktionen durchgeführt werden, wird ein Transaktionsfile mit dem Namen \quotes{<<ethereum-adresse>>-<<datum>>.json} und den Daten \textit{Datum, Wochentag, Ethereum-Adresse, Getränk} gespeichert. Sogleich werden beide Funktionsaufrufe getätigt und bei erfolgreicher Bestätigung beider Transaktionen, das gerade erstellte File wieder gelöscht. Somit soll sichergestellt werden, dass keine Transaktionen aufgrund von Verbindungsabbrüchen verloren gehen. \\
Anschließend erfolgt ein Reload der App und der Ablauf beginnt wieder bei 1.).